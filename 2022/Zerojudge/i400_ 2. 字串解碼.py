'''
(url: https://zerojudge.tw/ShowProblem?problemid=i400)

有一個字串加密系統，對於一個長度為 n 的字串 s 和一個長度為 n 的 0/1 字串 (只會是0或1) ，會產生一個加密過後的字串 t，其中加密流程為以下兩個步驟：
1. 如果字串 e 中 1 的出現次數是偶數，則直接進第二步驟，出現次數是奇數則將字串 s 平分成兩等份，兩份順序交換後再接起來，如果字串長度是奇數，則最中間的字元不動位置。
2. 讓 i 從 1 到 n 迭代，如果 e[i] = 0 就將 s 的第一個字元切掉並接到字串 t 的最後一個字元，如果 e[i] = 1 就將 s 的最後一個字元切掉並接到字串 t 的最後一個字元。
以範例 1 為例， 陣列為 10110，其中 1 出現的次數為奇數，因此需要交換字串 s 從 BCAAD 變為 ADABC。接下來執行第二階段，其中過程如下。
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
|   i   |    0    |    1    |   2    |   3    |   4    |
|_ _ _ _|_ _ _ _ _|_ _ _ _ _|_ _ _ _ |_ _ _ _ |_ _ _ _ |
|  e[i] |    1    |    0    |   1    |   1    |   0    |
|_ _ _ _|_ _ _ _ _|_ _ _ _ _|_ _ _ _ |_ _ _ _ |_ _ _ _ |
|   s   |  ADAB   |   DAB   |   DA   |   D    |   空   |
|_ _ _ _|_ _ _ _ _|_ _ _ _ _|_ _ _ _ |_ _ _ _ |_ _ _ _ |
|   t   |    C    |   CA    |   CAB  |  CABA  | CABAD  |
|_ _ _ _|_ _ _ _ _|_ _ _ _ _|_ _ _ _ |_ _ _ _ |_ _ _ _ |
給由 m 個 0/1 字串的加密表和按照順序加密原字串後得到加密過後的字串，請嘗試還原出原本的字串。

輸入說明
第一行輸入兩個數字 m, n ，接下來有 m 個長度為 n 的 01 字串，最後輸入一個長度為 n 的加密字串, 字串均由大寫字母組成。

輸出說明
輸出解密後的字串。

範例輸入 #1
1 5
10110
CABAD
範例輸出 #1
BCAAD

範例輸入 #2
3 6
111110
101101
000000
RETYWQ
範例輸出 #2
QWERTY
'''

m,n = map(int,input().split())
Case=[]
for i in range(m):
    Case=[str(x) for x in input().split()]+Case
t = input()
for e in Case:
    s = ''
    sm=0
    e=list(reversed(e))
    for i in e:
        if i=='0':
            s = t[-1] + s
        else:
            s = s + t[-1]
            sm+=1
        t = t[:-1]
    if sm%2==1:
        if len(s)%2==1:
            s = s[len(s)//2+1:] + s[len(s)//2] + s[:len(s)//2]
        else:
            s = s[len(s)//2:] + s[:len(s)//2]
    t = s
print(s)
