'''
(url: https://zerojudge.tw/ShowProblem?problemid=h082)

內容
有 n 的人要比賽，每個人的戰力為 S[1], S[2], ... , S[n]，而應變力為 T[1], T[2], ... , T[n]，編號為 1 到 n。

一開始將這 n 個人按照編號為 idx[1], idx[2], ... ,idx[n] 的順序排成一列，並從陣列前端開始兩兩一組進行配對競賽，
若該 round 有奇數人數，則最後一個烙單的人直接晉級下一 round，並不獲得戰力和應變力數值的增加。

每一場競賽的勝負判斷規則如下，假設第一個人的戰力為 a，應變力為 b，第二個人的戰力為 c，應變力為 d
1. 若 ab >= cd 則第一個人獲勝，並且勝利方 (第一個人) 的戰力變為 a + cd /(2b)，應變力變為 b + cd /(2a)，失敗方 (第二個人) 的戰力變為 c + (c/2)，應變力變為 d + (d/2)。
2. 若 ab < cd 則第二個人獲勝，並且勝利方 (第二個人) 的戰力變為 c + ab /(2d) , 應變力變為 d + ab /(2c)，失敗方 (第一個人) 的戰力變為 a + (a/2)，應變力變為 b + (b/2)。

以上除法皆為無條件捨去

該 round 每組勝負揭曉後，按照原有順序將他們排列並分成勝利組和失敗組，失敗組中若有人已經輸了 m 次則被淘汰，
再將失敗組接在勝利組之後形成新的排列進行下一 round，直到僅剩一個人成為最終勝利者，並輸出他的編號。

範例輸入 #1
4 1
4 2 5 3
2 5 1 5
1 2 3 4
範例輸出 #1
4

範例輸入 #2
4 5
4 1 5 3
6 5 1 6
4 1 3 2
範例輸出 #2
1

提示 ：
範例輸入 1
第 1 輪的編號為: {1, 2, 3, 4}, 戰力為: {4, 2, 5, 3}, 應變力為: {2, 5, 1, 5}, 失敗次數為: {1, 0, 1, 0}
第 2 輪的編號為: {2, 4}, 戰力為: {6, 2, 7, 3}, 應變力為: {3, 7, 1, 5}, 失敗次數為: {1, 1, 1, 0}

範例輸入 2
第 1 輪的編號為: {4, 1, 3, 2}, 戰力為: {4, 1, 5, 3}, 應變力為: {6, 5, 1, 6}, 失敗次數為: {0, 1, 0, 1}
第 2 輪的編號為: {1, 3, 4, 2}, 戰力為: {5, 1, 7, 4}, 應變力為: {8, 7, 1, 9}, 失敗次數為: {0, 2, 1, 1}
第 3 輪的編號為: {1, 4, 3, 2}, 戰力為: {5, 1, 10, 4}, 應變力為: {8, 10, 1, 9}, 失敗次數為: {0, 3, 1, 2}
第 4 輪的編號為: {1, 3, 4, 2}, 戰力為: {7, 1, 15, 6}, 應變力為: {11, 15, 1, 13}, 失敗次數為: {0, 4, 2, 2}
第 5 輪的編號為: {1, 4, 3, 2}, 戰力為: {7, 1, 22, 6}, 應變力為: {12, 22, 1, 14}, 失敗次數為: {0, 5, 2, 3}
第 6 輪的編號為: {1, 3, 4}, 戰力為: {10, 1, 33, 9}, 應變力為: {18, 33, 1, 21}, 失敗次數為: {0, 5, 3, 3}
第 7 輪的編號為: {1, 4, 3}, 戰力為: {10, 1, 49, 9}, 應變力為: {19, 33, 1, 21}, 失敗次數為: {0, 5, 3, 4}
第 8 輪的編號為: {1, 3, 4}, 戰力為: {14, 1, 49, 13}, 應變力為: {28, 33, 1, 31}, 失敗次數為: {0, 5, 4, 4}
第 9 輪的編號為: {1, 4, 3}, 戰力為: {14, 1, 73, 13}, 應變力為: {29, 33, 1, 31}, 失敗次數為: {0, 5, 4, 5}
第 10 輪的編號為: {1, 3}, 戰力為: {20, 1, 73, 19}, 應變力為: {43, 33, 1, 46}, 失敗次數為: {0, 5, 5, 5}
'''
n,m = map(int,input().split())
S = [0]+[int(x) for x in input().split()]
T = [0]+[int(x) for x in input().split()]
idx = [int(x) for x in input().split()]
winner = []
loser = []
lose_T = [0]*(n+1)
lose_T[0] = m+1
while len(idx)>1:
    winner = []; loser = []
    for i in range(0,len(idx),2):
        if i==len(idx)-1:
            winner.append(idx[i])
        else:
            p1 = idx[i]; p2 = idx[i+1]
            a = S[p1]; b = T[p1]; c = S[p2]; d = T[p2]
            if a*b>=c*d:
                winner.append(p1)
                S[p1]+=c*d//(2*b)
                T[p1]+=c*d//(2*a)
                lose_T[p2]+=1
                if lose_T[p2]<m:
                    loser.append(p2)
                    S[p2]+=(c//2)
                    T[p2]+=(d//2)
            else:
                winner.append(p2)
                S[p2]+=a*b//(2*d)
                T[p2]+=a*b//(2*c)
                lose_T[p1]+=1
                if lose_T[p1]<m:
                    loser.append(p1)
                    S[p1]+=(a//2)
                    T[p1]+=(b//2)
    idx = winner+loser
print(idx[0])
