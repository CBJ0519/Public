/*
(url: https://zerojudge.tw/ShowProblem?problemid=e522)

內容
跑長編碼(Run-Length Coding)是一種常見的資料壓縮技術，特別適用於字串樣式重複頻率高的情況。
其編碼格式為(重複樣式,重複次數)，例如一個二元字串 0000001111111001111可編碼為(0,6) (1,7) (0,2) (1,4)，因為樣式0 重複了 6 次，而之後的樣式1則重複了 7 次。
寫一個程式來壓縮一個長位元串，並輸出壓縮比率(壓縮後位元個數除以原位元個數，四捨五入到整數百分比)。
重複位元的長度用3個位元來表示(最大連續長度為7)，放在重複位元的後面，形成一個4位元的碼字(code word)。
輸入是一長串連續的位元(長度小於500)，不可有0、1之外的字元、數字、或空格。
輸出則是編碼後的4位元碼字，可能是(0,連續0的長度)或(1,連續1的長度)，兩個碼字之間用一個空格分開，最後是四捨五入的壓縮率。
如果輸入不是一個2進制位元串，直接輸出-1。

輸入說明
輸入資料中第一列為一整數n，代表接下來有n組測試資料。
第二列開始共有n列，每列有一個二元字串。

輸出說明
輸出跑長編碼後的數個4位元碼字以及壓縮率，各碼字與壓縮率皆用空格分開。

範例輸入 #1
4
00010000000111111101111111
11111100000000000000111111111111110000
0011  1111100000101010
HINET0800000123

範例輸出 #1
0011 1001 0111 1111 0001 1111 92%
1110 0111 0111 1111 1111 0100 63%
-1
-1
*/
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    string s, binary[8]={"000","001","010","011","100","101","110","111"};
    cin>>n;
    cin.ignore();
    while(n--){
        getline(cin,s);
        string t="";
        int ori=s.length();
        int after=0;
        int times=1;
        char ch=s[0];
        if (ch!='0' && ch!='1'){
            cout<<-1;
            continue;
        }
        for(int i=1;i<=s.length();i++){
            if(i!=s.length() && s[i]!='0' && s[i]!='1'){
                after=-1;
                break;
            }
            if(s[i]!=ch){
                t+=ch;
                t+=binary[times];
                t+=" ";
                times=1;
                ch=s[i];
                after+=4;
            }
            else{
                times++;
                if(times==7){
                    t+=ch;
                    t+=binary[times];
                    t+=" ";
                    times=1;
                    after+=4;
                    ch=s[i+1];
                    i++;
                }
            }
        }
    if (after==-1) cout<<-1<<"\n";
    else cout<<t<<setprecision(0)<<fixed<<(double)after*100/ori<<"%"<<"\n";
    }
}
